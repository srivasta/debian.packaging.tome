/* File: util.pkg */

/*
 * Purpose: Lua interface defitions for miscellaneous routines.
 * To be processed by tolua to generate C source code.
 */

$#include "angband.h"
$#include "plots.h"

typedef char* cptr;
typedef int errr;
typedef unsigned char bool;
typedef unsigned char byte;
typedef signed short s16b;
typedef unsigned short u16b;
typedef signed int s32b;
typedef unsigned int u32b;

#define TRUE
#define FALSE

#define ESCAPE	'\033'

#define TERM_DARK                0  /* 'd' */   /* 0,0,0 */
#define TERM_WHITE               1  /* 'w' */   /* 4,4,4 */
#define TERM_SLATE               2  /* 's' */   /* 2,2,2 */
#define TERM_ORANGE              3  /* 'o' */   /* 4,2,0 */
#define TERM_RED                 4  /* 'r' */   /* 3,0,0 */
#define TERM_GREEN               5  /* 'g' */   /* 0,2,1 */
#define TERM_BLUE                6  /* 'b' */   /* 0,0,4 */
#define TERM_UMBER               7  /* 'u' */   /* 2,1,0 */
#define TERM_L_DARK              8  /* 'D' */   /* 1,1,1 */
#define TERM_L_WHITE             9  /* 'W' */   /* 3,3,3 */
#define TERM_VIOLET             10  /* 'v' */   /* 4,0,4 */
#define TERM_YELLOW             11  /* 'y' */   /* 4,4,0 */
#define TERM_L_RED              12  /* 'R' */   /* 4,0,0 */
#define TERM_L_GREEN            13  /* 'G' */   /* 0,4,0 */
#define TERM_L_BLUE             14  /* 'B' */   /* 0,4,4 */
#define TERM_L_UMBER            15  /* 'U' */   /* 3,2,1 */

#define HOOK_MONSTER_DEATH      0
#define HOOK_OPEN               1
#define HOOK_GEN_QUEST          2
#define HOOK_END_TURN           3
#define HOOK_FEELING            4
#define HOOK_NEW_MONSTER        5
#define HOOK_GEN_LEVEL          6
#define HOOK_BUILD_ROOM1        7
#define HOOK_NEW_LEVEL          8
#define HOOK_QUEST_FINISH       9
#define HOOK_QUEST_FAIL         10
#define HOOK_GIVE               11
#define HOOK_CHAR_DUMP          12
#define HOOK_INIT_QUEST         13
#define HOOK_WILD_GEN           14
#define HOOK_DROP               15
#define HOOK_IDENTIFY           16
#define HOOK_MOVE               17
#define HOOK_STAIR              18
#define HOOK_MONSTER_AI         19
#define HOOK_PLAYER_LEVEL       20
#define HOOK_WIELD              21
#define HOOK_INIT               22
#define HOOK_QUAFF              23
#define HOOK_AIM                24
#define HOOK_USE                25
#define HOOK_ACTIVATE           26
#define HOOK_ZAP                27
#define HOOK_READ               28
#define HOOK_CALC_BONUS         29
#define HOOK_CALC_POWERS        30
#define HOOK_KEYPRESS           31
#define HOOK_CHAT               32
#define HOOK_MON_SPEAK          33
#define HOOK_MKEY               34
#define HOOK_BIRTH_OBJECTS      35
#define HOOK_ACTIVATE_DESC      36
#define HOOK_INIT_GAME          37
#define HOOK_ACTIVATE_POWER     38
#define HOOK_ITEM_NAME          39
#define HOOK_SAVE_GAME          40
#define HOOK_LOAD_GAME          41
#define HOOK_LEVEL_REGEN        42
#define HOOK_LEVEL_END_GEN      43
#define HOOK_BUILDING_ACTION    44
#define HOOK_PROCESS_WORLD      45
#define HOOK_WIELD_SLOT         46
#define HOOK_STORE_STOCK        47
#define HOOK_STORE_BUY          48
#define HOOK_GEN_LEVEL_BEGIN    49
#define HOOK_GET                50
#define HOOK_REDRAW             51
#define HOOK_RECALC_SKILLS      52
#define HOOK_ENTER_DUNGEON      53
#define HOOK_FIRE               54
#define HOOK_EAT                55
#define HOOK_DIE                56
#define HOOK_CALC_HP            57
#define HOOK_GF_COLOR           58
#define HOOK_GF_EXEC            59
#define HOOK_CALC_MANA          60
#define HOOK_LOAD_END           61
#define HOOK_RECALL             62
#define HOOK_FOLLOW_GOD         63
#define HOOK_SACRIFICE_GOD      64
#define HOOK_BODY_PARTS         65
#define HOOK_APPLY_MAGIC        66
#define HOOK_PLAYER_EXP         67
#define HOOK_BIRTH              68
#define HOOK_CALC_LITE		69
#define HOOK_LEARN_ABILITY      70
#define HOOK_MOVED              71
#define HOOK_GAME_START         72
#define HOOK_TAKEOFF            73
#define HOOK_CALC_WEIGHT        74

extern s32b turn;
extern s32b old_turn;
extern s16b cur_wid;
extern s16b cur_hgt;

extern void disturb(int stop_search, int flush_output);
extern s32b bst(s32b what, s32b t);
$static char *path_build_lua(cptr path, cptr file){static char buf[1025]; path_build(buf, 1024, path, file); return buf;}
static char *path_build_lua@path_build(cptr path, cptr file);
extern void move_cursor(int row, int col);
extern void flush(void);

#define ESCAPE

extern bool inkey_scan;
extern char inkey(void);
extern void cmsg_print(byte color, cptr msg);
extern void msg_print(cptr msg);
extern void screen_save(void);
extern void screen_load(void);
extern errr Term_save(void);
extern errr Term_load(void);
extern void c_put_str(byte attr, cptr str, int row, int col);
extern void c_prt(byte attr, cptr str, int row, int col);
extern void prt(cptr str, int row, int col);
extern void message_add(byte type, cptr msg, byte color);
extern void display_message(int x, int y, int split, byte color, cptr t);
extern void clear_from(int row);
extern bool askfor_aux(char *buf, int len);
extern bool get_string(cptr prompt, char *buf, int len);
extern bool get_check(cptr prompt);
extern bool get_com_lua @ get_com(cptr promtp, int *com = 0);
extern s32b get_quantity(cptr prompt, s32b max);
extern int test_monster_name(cptr name);
extern int test_item_name(cptr name);
extern int luck(int min, int max);
extern cptr get_player_race_name(int pr, int ps);
extern void quit(cptr str);
extern s32b value_scale(int value, int vmax, int max, int min);
extern void text_out_c(byte a, cptr str);
extern void text_out(cptr str);
extern bool change_option(cptr name, bool value);

extern int process_hooks_restart;
extern void dump_hooks(int h_idx);
extern void add_hook_script(int h_idx, char *script, cptr name);
extern void del_hook_name(int h_idx, cptr name);
extern bool tome_dofile(char *file);
extern bool tome_dofile_anywhere(cptr dir, char *file, bool test_exist = TRUE);
extern int exec_lua(char *file);
extern void dump_lua_stack(int min, int max);
extern cptr string_exec_lua(char *file);

extern void lua_print_hook@print_hook(cptr str);

/* Savefile stuff */
extern void register_savefile(int num);
extern void save_number_key(char *key, s32b val);


/* Tables */
extern byte adj_mag_study[100];
extern byte adj_mag_mana[100];
extern byte adj_mag_fail[100];
extern byte adj_mag_stat[100];
extern byte adj_chr_gold[100];
extern byte adj_int_dev[100];
extern byte adj_wis_sav[100];
extern byte adj_dex_dis[100];
extern byte adj_int_dis[100];
extern byte adj_dex_ta[100];
extern byte adj_str_td[100];
extern byte adj_dex_th[100];
extern byte adj_str_th[100];
extern byte adj_str_wgt[100];
extern byte adj_str_hold[100];
extern byte adj_str_dig[100];
extern byte adj_str_blow[100];
extern byte adj_dex_blow[100];
extern byte adj_dex_safe[100];
extern byte adj_con_fix[100];
extern byte adj_con_mhp[100];

/* Repeat stuff */
extern void repeat_push(int what);
extern bool repeat_pull(int *what = 0);
extern void repeat_check(void);
extern void get_count(int number, int max);


/*** Features flags -- DG ***/
#define FF1_NO_WALK             0x00000001L
#define FF1_NO_VISION           0x00000002L
#define FF1_CAN_LEVITATE        0x00000004L
#define FF1_CAN_PASS            0x00000008L
#define FF1_FLOOR               0x00000010L
#define FF1_WALL                0x00000020L
#define FF1_PERMANENT           0x00000040L
#define FF1_CAN_FLY             0x00000080L
#define FF1_REMEMBER            0x00000100L
#define FF1_NOTICE              0x00000200L
#define FF1_DONT_NOTICE_RUNNING 0x00000400L
#define FF1_CAN_RUN             0x00000800L
#define FF1_DOOR                0x00001000L
#define FF1_SUPPORT_LIGHT       0x00002000L
#define FF1_CAN_CLIMB           0x00004000L
#define FF1_TUNNELABLE          0x00008000L
#define FF1_WEB                 0x00010000L
#define FF1_ATTR_MULTI          0x00020000L
#define FF1_SUPPORT_GROWTH      0x00040000L

/* Cave stuff */
struct cave_type
{
	u16b info;		/* Hack -- cave flags */

	byte feat;		/* Hack -- feature type */

	s16b o_idx;		/* Object in this grid */

	s16b m_idx;		/* Monster in this grid */

	s16b t_idx;		/* trap index (in t_list) or zero       */

	s16b special;
        s16b special2; /* Special cave info */

	s16b inscription;       /* Inscription of the grid */

	byte mana;              /* Magical energy of the grid */

	byte mimic;		/* Feature to mimic */

        s16b effect;            /* The lasting effects */
};

extern cptr ANGBAND_SYS;
extern cptr ANGBAND_KEYBOARD;
extern cptr ANGBAND_GRAF;
extern cptr ANGBAND_DIR;
extern cptr ANGBAND_DIR_APEX;
extern cptr ANGBAND_DIR_BONE;
extern cptr ANGBAND_DIR_CORE;
extern cptr ANGBAND_DIR_DNGN;
extern cptr ANGBAND_DIR_DATA;
extern cptr ANGBAND_DIR_EDIT;
extern cptr ANGBAND_DIR_FILE;
extern cptr ANGBAND_DIR_HELP;
extern cptr ANGBAND_DIR_INFO;
extern cptr ANGBAND_DIR_MODULES;
extern cptr ANGBAND_DIR_NOTE;
extern cptr ANGBAND_DIR_SAVE;
extern cptr ANGBAND_DIR_SCPT;
extern cptr ANGBAND_DIR_PREF;
extern cptr ANGBAND_DIR_PATCH;
extern cptr ANGBAND_DIR_USER;
extern cptr ANGBAND_DIR_XTRA;
extern cptr ANGBAND_DIR_CMOV;

extern bool los(int y1, int x1, int y2, int x2);
$static bool lua_cave_is(cave_type *c_ptr, s32b flag) { return (f_info[c_ptr->feat].flags1 & flag) ? TRUE : FALSE; }
static bool lua_cave_is @ cave_is(cave_type *c_ptr, s32b flag);
extern cave_type *lua_get_cave @ cave(int y, int x);
extern void set_target(int y, int x);
extern void get_target(int dir, int *y = 0, int *x = 0);
extern bool m_allow_special[max_r_idx];
extern bool k_allow_special[max_k_idx];
extern bool a_allow_special[max_a_idx];
extern void cave_set_feat(int y, int x, int feat);
extern bool show_file(cptr name, cptr what, int line, int mode);
extern s16b target_who;
extern s16b target_col;
extern s16b target_row;
extern int max_bact;

extern s16b ddd[9];
extern s16b ddx[10];
extern s16b ddy[10];
extern s16b ddx_ddd[9];
extern s16b ddy_ddd[9];


/* Gen stuff */
extern void get_map_size(bool full_text, char *name, int *ysize = 0, int *xsize = 0);
extern void load_map(bool full_text, char *name, int *y = 2, int *x = 2);
extern bool alloc_room(int by0, int bx0, int ysize, int xsize, int *y1 = 0, int *x1 = 0, int *y2 = 0, int *x2 = 0);

/* Ingame help */
extern bool option_ingame_help;

/* Misc stuff */
extern char *lua_input_box@input_box(cptr title, int max);
extern char lua_msg_box@msg_box(cptr title);
extern s32b rescale(s32b x, s32b max, s32b new_max);
$static const char *player_name_lua(void){return (const char *)player_name;}
static const char *player_name_lua@player_name();

/* Temp files */
extern void lua_make_temp_file@make_temp_file();
extern void lua_close_temp_file@close_temp_file();
extern void lua_end_temp_file@end_temp_file();
extern cptr lua_get_temp_name@get_temp_name();

/* Quarks */
extern cptr quark_str(s16b num);
extern s16b quark_add(cptr str);

/* Modules */
extern void module_reset_dir(cptr dir, cptr new_path);
extern void scansubdir(cptr dir);
extern bool file_exist(char *buf);
extern cptr game_module;

/* Input */
extern int get_keymap_dir(char ch);

/*
 * Timers
 */
struct timer_type
{
        timer_type *next;       /* The next timer in the list */

        bool enabled;           /* Is it currently counting? */

        s32b delay;             /* Delay between activations */
        s32b countdown;         /* The current number of turns passed, when it reaches delay it fires */

        cptr callback;          /* The lua function to call upon firing(no C callback yet .. maybe) */
};

extern timer_type *new_timer(cptr callback, s32b delay);
extern void del_timer(timer_type *t_ptr);

/*
 * Lists
 */
struct list_type
{
};
extern list_type *lua_create_list@create_list(int size);
extern void lua_delete_list@delete_list(list_type *, int size);
extern void lua_add_to_list@add_to_list(list_type *, int idx, cptr str);
extern void lua_display_list@display_list(int y, int x, int h, int w, cptr title, list_type *list, int max, int begin, int sel, byte sel_color);
